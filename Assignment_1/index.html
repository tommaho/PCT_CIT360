<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sorts</title>
    <style media="all">
        html {
            font-family: sans-serif;
        }
        ul {
            list-style: none;
        }
        .codeblock {
            //color: white;
            background-color: lightgrey;

        }

    </style>
<script type="text/javascript" src="scripts/assignment_1.js">


    /**
     * Selection sort algorithm.
     * @param theArray
     */
    function selectionSort(theArray) {
        let smallest = 0;
        let smallestPosition = 0;
        let temp = 0;

        for (let i = 0; i < theArray.length - 1; i++) {
            smallest = theArray[i];
            smallestPosition = i;
            for (let j = i + 1; j < theArray.length; j++) {
                if (theArray[j] < smallest) {
                    smallest = theArray[j];
                    smallestPosition = j;
                }
            }
            temp = theArray[i];
            theArray[i] = theArray[smallestPosition];
            theArray[smallestPosition] = temp;

        }

    }


    /**
     * Insertion sort algorithm.
     * @param theArray
     */
    function insertionSort(theArray) {
        let currentValue = 0;
        let j = 0;

        for (let i = 1; i < theArray.length; i++) {
            currentValue = theArray[i];
            j = i - 1;

            while (j >= 0 && theArray[j] > currentValue) {
                theArray[j+1] = theArray[j];
                j--;
            }
            theArray[j+1] = currentValue;
        }
    }


    /**
     * Bubble sort algorithm.
     * @param theArray
     */
    function bubbleSort(theArray) {
        let swapped = true;
        let temp = 0;

        while (swapped){
            swapped = false;
            for (let i = 0; i < theArray.length; i++) {
                if(theArray[i] > theArray[i + 1]) {
                    swapped = true;
                    temp = theArray[i];
                    theArray[i] = theArray[i + 1];
                    theArray[i + 1] = temp;
                }
            }
        }
    }

    /**
     * Copied then ported to js from code shared by Dr. G.:
     *
     * @param array
     */
    function quickSort(array) {
        quickSortHelper(array, 0, array.length-1);
    }


    /**
     * Copied then ported to js from code shared by Dr. G.:
     *
     * Using the quick sort sort alg. to sort the array values between the
     * indicated positions
     *
     * @param array
     * @param min
     * @param max
     */
    function quickSortHelper(array, min, max) {
        let i = min;
        let j = max;
        let mid = (min + max)/ 2;
        let temp;

        let pivot = array[mid];

        while(i <= j) {
            while(array[i] < pivot)
                i++;
            while (array[j] > pivot)
                j--;
            if(i <= j) {
                //swap the elements
                temp = array[i];
                array[i] = array[j];
                array[j] = temp;
                i++;
                j--;
            }
        }

        if(min < j)
            quickSortHelper(array, min, j);
        if(i < max)
            quickSortHelper(array, i, max);
    }

    /**
     * Copied then ported to js from code shared by Dr. G.:
     */
    function mergeSort(array) {
        mergeSortHelper(array, 0, array.length-1);
    }

    /**
     * Copied then ported to js from code shared by Dr. G.:
     *
     * Merge sort the array from index low to index high
     *
     * @param array
     * @param low
     * @param high
     */
    function mergeSortHelper(array, low, high) {
        if (high <= low) return;

        let mid = (low+high)/2;
        mergeSortHelper(array, low, mid);   //merge sort the left side
        mergeSortHelper(array, mid+1, high);  //merge sort the right side
        merge(array, low, mid, high);   //merge the two sorted parts together

    }


    /**
     * Copied then ported to js from code shared by Dr. G.:
     *
     * assuming the array parts from low to mid and from mid to high are sorted,
     * the method merger the two parts
     *
     * @param array
     * @param low
     * @param mid
     * @param high
     */
    function merge(array, low, mid, high) {
        // Creating temporary subarrays
        let leftArray = []; //new int[mid - low + 1]; array lengths are default dynamic in js
        let rightArray = []; //new int[high - mid]; array lengths are default dynamic in js

        // Copying our subarrays into temporaries
        for (let i = 0; i < leftArray.length; i++)
        leftArray[i] = array[low + i];
        for (let i = 0; i < rightArray.length; i++)
        rightArray[i] = array[mid + i + 1];

        // Iterators containing current index of temp subarrays
        let leftIndex = 0;
        let rightIndex = 0;

        // Copying from leftArray and rightArray back into array
        for (let i = low; i < high + 1; i++) {
            // If there are still uncopied elements in R and L, copy minimum of the two
            if (leftIndex < leftArray.length && rightIndex < rightArray.length) {
                if (leftArray[leftIndex] < rightArray[rightIndex]) {
                    array[i] = leftArray[leftIndex];
                    leftIndex++;
                } else {
                    array[i] = rightArray[rightIndex];
                    rightIndex++;
                }
            } else if (leftIndex < leftArray.length) {
                // If all elements have been copied from rightArray, copy rest of leftArray
                array[i] = leftArray[leftIndex];
                leftIndex++;
            } else if (rightIndex < rightArray.length) {
                // If all elements have been copied from leftArray, copy rest of rightArray
                array[i] = rightArray[rightIndex];
                rightIndex++;
            }
        }
    }

    /**
     * Create an array of random values <= 1000, of size 'size'.
     * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from
     * and: https://stackoverflow.com/questions/5836833/create-an-array-with-random-values
     * @param size number of elements in array
     * @returns {number[]}
     */
    function randomArray(size, max){
        return Array.from({length: size}, () => Math.floor(Math.random() * (max + 1)));
    }


    function run() {

        //clear embedded console;
        // const logTarget = document.getElementById("output");
        // logTarget.innerHTML += "Algorithm: " + algo.name + "<br>";

        let shortArraySize = 100;
        let longArraySize = 1000;
        let maxValue = 1000;

        //map is a dict-like iterable in ES6 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
        let shortResultsMap = new Map();
        let shortArray = randomArray(shortArraySize, maxValue);

        /*
        Notes on the code below:
            Passing as anonymous function defers execution, see:
            https://stackoverflow.com/questions/13286233/pass-a-javascript-function-as-parameter#13286241

            The .slice() method creates a shallow copy, see:
            https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice
            and
            https://stackoverflow.com/questions/51164161/spread-syntax-vs-slice-method
         */
        shortResultsMap.set("Bubble sort, n = 100:", getAlgoAvgRunTime(()=>{bubbleSort(shortArray.slice())}));
        shortResultsMap.set("Selection sort, n = 100:", getAlgoAvgRunTime(()=>{selectionSort(shortArray.slice())}));
        shortResultsMap.set("Insertion sort, n = 100:", getAlgoAvgRunTime(()=>{insertionSort(shortArray.slice())}));
        shortResultsMap.set("Quick sort, n = 100:", getAlgoAvgRunTime(()=>{quickSort(shortArray.slice())}));
        shortResultsMap.set("Merge sort, n = 100:", getAlgoAvgRunTime(()=>{mergeSort(shortArray.slice())}));

        //
    console.log(shortResultsMap);

        let longResultsMap = new Map();
        let longArray = randomArray(longArraySize, maxValue);

        longResultsMap.set("Bubble sort, n = 1000:", getAlgoAvgRunTime(()=>{bubbleSort(longArray.slice())}));
        longResultsMap.set("Selection sort, n = 1000:", getAlgoAvgRunTime(()=>{selectionSort(longArray.slice())}));
        longResultsMap.set("Insertion sort, n = 1000:", getAlgoAvgRunTime(()=>{insertionSort(longArray.slice())}));
        longResultsMap.set("Quick sort, n = 1000:", getAlgoAvgRunTime(()=>{quickSort(longArray.slice())}));
        longResultsMap.set("Merge sort, n = 1000:", getAlgoAvgRunTime(()=>{mergeSort(longArray.slice())}));

        console.log(longResultsMap);

        //document.getElementById("output").innerHTML = "Bubble sort on 100 elements averages: " +
        //    avgRunTime + " milliseconds<br>";



        let sortedLongMap = new Map([...longResultsMap.entries()].sort((a,b) => a[1] - b[1]));

        console.log(sortedLongMap);




    }

    /**
     * Generic algorithm timing helper.
     *
     * @param algo an anonymous function to fire when called within this function. In this case,
     *  the assignments sort algorithms.
     *  Uses performance.now for timestamping:
     *  https://developer.mozilla.org/en-US/docs/Web/API/Performance/now
     *
     * @returns {number} //time for algo to process.
     */

    function getAlgoAvgRunTime(algo){ // , array){

        let runTimes = [];
        let avgRunTime = 0;

        for (let i = 0; i < 100; i++) {

            let startTime = performance.now(); // nanosecond time
            algo(); //array);
            let endTime = performance.now();

            runTimes.push(endTime - startTime); // nanosecond time

        }

        avgRunTime = runTimes.reduce((a, b) => a + b, 0) / runTimes.length;

        return Math.floor(avgRunTime * 1000000); //convert nanoseconds to milliseconds, no decimals
    }


</script>

</head>
<body>
<header>
<ul>
    <li>Tom Mahoney</li>
    <li>CIT360</li>
    <li>Fall 2022</li>
</ul>
    <details>
        <summary>Assignment Description - Comparing Sorting Algorithms (click to expand)</summary>
        <p>In this assignment, you will compare the practical run times of selection, insertion, bubble, merge, and
        the quick sorts. Make sure that all sort algorithms work with the same data in each test. Run the
        experiment several times and average all the obtained times. Graphically display the findings.</p>
        <p>
        Here are the steps that need to be completed:
        <ol>
        <li>
            Write implementations of selection, insertion, bubble, merge, and quick sorts.
        </li>
        <li>
            Write a method that fills an array with some random numbers.
        </li>
        <li>
            Using a loop, repeatedly, randomize a new array, and give its copies to each one of the
            sorts. Calculate the completion time of each sort. See below how to time a method. Save
            the calculated time in an array.
        </li>
        <li>
            At the completion of the loop, calculate the average sort time for each one of the sorts.
        </li>
        <li>
            Display your findings in a formatted manner for two cases:
            <ol type="a">
                <li>
                    Case 1: small array size n <= 100
                </li>
                <li>
                    Case 2: large array size n >= 10000
                </li>
            </ol>
        </li>


    </ol>
        </p>
        <p>Some general notes:</p>
        <ol type="a">

       <li>Use the following code to measure amount of time (in Nano seconds) that a method takes
        to complete:
           <p class="codeblock"><code>
        long startTime = System.nanoTime();<br>
        // ... the code being timed ...<br>
        long estimatedTime = System.nanoTime() - startTime;
           </code></p>
        <li>Array size needs to be large, say 1000. Number of iterations also need to be large. Declare
            constants and use values that work well with your hardware.</li>
            <li>Your program needs to run without requiring any input from user.</li>
            <li>I/O must be formatted, clear, and informative.</li>
            <li>Document you code.</li>
        <li>If you are copying a code from a source, first document the code source, and second, you
        must understand the code well enough to be able to reproduce it yourself. You are not
            allowed to copy code from other students.</li>
        <li>Here is a sample output for case 1 :
            <p class="codeblock"><code>
        Array size: 100
                <br>        Max value: 1000
                <br>Number of iterations: 500
                <br>Average run times (in Nano seconds):
                <br>Selection sort: **************** 200
                <br>Insertion sort: ************ 160
                <br>Bubble sort: ************** 170
                <br>Quick sort: ******** 120
                <br>Merge sort: *********** 150
            </code></p>
        </li>

        </ol>

    </details>

</header>

<main>

    <section class="code_control">
        <button onclick="run()">Run Code</button>
        <button>Reset Page</button>
    </section>

    <section class="code_ouput">
    <h4>Code Output:</h4>
    <div class="codeblock">
    <code id="output">Click "run code".</code>
    </div></section>


</main>
</body>
</html>